---
title: 338. 比特位计数
tags:
  - Bit Manipulation
difficulty: single
link: https://leetcode-cn.com/problems/counting-bits/
date: 2021-10-22
---

### 题目

给你一个整数 `n` ，对于 `0 <= i <= n` 中的每个 `i` ，计算其二进制表示中 **`1` 的个数** ，返回一个长度为 `n + 1` 的数组 `ans` 作为答案。

**示例 1：**

```text
输入：n = 2
输出：[0,1,1]
解释：
0 --> 0
1 --> 1
2 --> 10
```

**示例 2：**

```text
输入：n = 5
输出：[0,1,1,2,1,2]
解释：
0 --> 0
1 --> 1
2 --> 10
3 --> 11
4 --> 100
5 --> 101
```

**提示：**

- `0 <= n <= 105`

**进阶：**

- 很容易就能实现时间复杂度为 `O(n log n)` 的解决方案，你可以在线性时间复杂度 `O(n)` 内用一趟扫描解决此问题吗？
- 你能不使用任何内置函数解决此问题吗？（如，C++ 中的 `__builtin_popcount` ）

### 解法

### 解法1

解题思路：通过`LeetCode 0191`的算法，求出每一个元素的实际结果

```cpp
class Solution {
private:
    int hammingWeight(uint32_t n) {
        int result = 0;
        while(n > 0) {
            n &= n - 1;
            result++;
        }
        return result;
    }
public:
    vector<int> countBits(int n) {
        vector<int> result(n + 1, 0);
        for (int i = 1; i <= n; ++i) {
            result[i] = hammingWeight((uint32_t)i);
        }
        return result;
    }
};
```

算法复杂度

- 时间复杂度:`O(NlogN)`
- 空间复杂度:`O(1)`

#### 解法2

解题思路：整理二进制数据表规律，可以发现`3`等同于`2+1`，`2`代表一个最高有效位，此时可以整理动态规划公式

```text
0 --> 000-0
1 --> 000-1
2 --> 001-0
3 --> 001-1
```

最高有效位规律：`result[i] = result[i - high] + 1`

对于最高有效位规律需要统计最高位`high`，该部分会产生`O(logN)`复杂度，可采用最低位作为状态变化

最低位规律：`result[i] = result[i >> 1] + 1`

```cpp
class Solution {
public:
    vector<int> countBits(int n) {
        vector<int> result(n + 1, 0);
        for (int i = 1; i <= n; ++i) {
            result[i] = result[i >> 1] + (i & 1);
        }
        return result;
    }
};
```

算法复杂度

- 时间复杂度:`O(N)`
- 空间复杂度:`O(1)`
