## [137. 只出现一次的数字 II](https://leetcode-cn.com/problems/single-number-ii/)

### 题目

给你一个整数数组 `nums` ，除某个元素仅出现 **一次** 外，其余每个元素都恰出现 **三次 。**请你找出并返回那个只出现了一次的元素。

 **示例 1：**

```text
输入：nums = [2,2,3,2]
输出：3
```

**示例 2：**

```text
输入：nums = [0,1,0,1,0,1,99]
输出：99
```

 **提示：**

- `1 <= nums.length <= 3 * 10^4`
- `-2^31 <= nums[i] <= 2^31 - 1`
- `nums` 中，除某个元素仅出现 **一次** 外，其余每个元素都恰出现 **三次**

**进阶：**你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？

### 解法

### 解法1

解题思路：利用哈希表直接遍历所有元素，但会产生额外空间

```cpp
class Solution {
public:
    int singleNumber(vector<int>& nums) {
        unordered_map<int, int> count;
        for (auto &num: nums) {
            count[num]++;
        }
        for (auto & [first, second]: count) {
            if (second == 1) {
                return first;
            }
        }
        return 0;
    }
};
```

算法复杂度

- 时间复杂度:`O(n)`
- 空间复杂度:`O(n)`

#### 解法2

解题思路：针对所有元素各个位上`1`的个数进行统计，根据目标元素(只出现一次)和非目标元素(出现三次)在该位的表现存在如下情况

- 该位个数为`4`：目标元素和非目标元素同时有该位数字，需注意
- 该位个数为`3`：仅非目标元素有该位数字
- 该位个数为`1`：仅目标元素有该位数字，需注意
- 该位个数为`0`：目标元素和非目标元素同时没有该位数字

总结: 二进制位上`1`的个数大于`0`，且不为`3`，即代表目标元素存在该二进制位

```cpp
class Solution {
public:
    int singleNumber(vector<int>& nums) {
        int result = 0;
        for (int i = 0; i < 32; ++i) {
            int count = 0;
            for (auto &num: nums) {
                count += (num >> i) & 1;
            }
            if (count != 0 && count % 3 != 0) {
                result += 1 << i;
            }
        }
        return result;
    }
};
```

- 算法复杂度
  - 时间复杂度:`O(n)`
  - 空间复杂度:`O(1)`

#### 解法3

解题思路：根据解法二探讨更优的解法，即利用`one`,`two`,`three`表示各二进制位状态

- `one ^= num`：记录至目前元素`num`，二进制某位出现`1`次（当某位出现`3`次时有`one = 1` ，与`two = 1`共同表示「出现`3`次」)
- `two |= one & num`：记录至目前元素`num`，二进制某位出现`2`次 （当某位出现`2`次时，`two = 1`且`one = 0`
- `three = one & two`：记录至目前元素`num`，二进制某位出现`3`次（即当`one`和`two`对应位同时为`1`时`three = 1`)
- `one &= ~three`, `two &= ~three`：将`one`，`two`中出现了`3`次的对应位清零，实现「不考虑进位的三进制加法」

优化：从变量来看

- `one = one ^ num & ~two`:
  - 当`num = 1`时，只当`one = two = 0`时将`one`置`1`，代表出现`3N + 1`次；其余置`0`，根据值分别代表出现`3N`次和`3N + 2`次；
  - 当`num = 0`时，`one`不变；
- `two = two ^ num & ~one`:
  - 当`num = 1`时，只当`one = two = 0`时将`two`置`1`，代表出现`3N + 2`次；其余置，根据值分别代表出现`3N`次和`3N + 1`次；
  - 当`num = 0`时，`two`不变；

```cpp
// 原始
class Solution {
public:
    int singleNumber(vector<int>& nums) {
        int one = 0, two = 0, three;
        for (auto &num: nums) {
            two |= one & num;
            one ^= num;
            three = one & two;
            one &= ~three;
            two &= ~three;
        }
        return one;
    }
};
// 优化
class Solution {
public:
    int singleNumber(vector<int>& nums) {
        int one = 0, two = 0;
        for (auto &num: nums) {
            one = one ^ num & ~two;
            two = two ^ num & ~one;
        }
        return one;
    }
};
```

算法复杂度

- 时间复杂度:`O(n)`
- 空间复杂度:`O(1)`
